from typing import Dict, List, Tuple

import openpyxl
from openpyxl import Workbook
from openpyxl.utils import get_column_letter


def create_excel_table(old_weights: Dict[Tuple[int, int], List[float]],
                       old_biases: Dict[Tuple[int, int], float],
                       new_weights: Dict[Tuple[int, int], List[float]],
                       new_biases: Dict[Tuple[int, int], float],
                       output_filename: str) -> None:
    """
    Создает Excel-таблицу с результатами коррекции весов и смещений.
    
    Таблица будет иметь следующие столбцы:
      № слоя | № нейрона | № выхода | Предыдущий весовой коэффициент wij(t) |
      Предыдущий вес смещения Tj(t) | Новый весовой коэффициент wij(t+1) | Новый вес смещения Tj(t+1)
    
    Для каждого нейрона, имеющего несколько выходов, создаются столько строк,
    сколько весовых коэффициентов; смещение выводится только в первой строке.
    
    Args:
        old_weights: Словарь старых весов, ключ (layer, neuron), значение – список весов.
        old_biases: Словарь старых смещений, ключ (layer, neuron), значение – bias.
        new_weights: Словарь новых весов, структура аналогична.
        new_biases: Словарь новых смещений.
        output_filename: Имя выходного Excel-файла.
    """
    wb = Workbook()
    ws = wb.active
    ws.title = "Таблица 10"
    
    # Заголовки столбцов
    headers = [
        "№ слоя",
        "№ нейрона",
        "№ выхода",
        "Предыдущий весовой коэффициент wij(t)",
        "Предыдущий вес смещения Tj(t)",
        "Новый весовой коэффициент wij(t+1)",
        "Новый вес смещения Tj(t+1)"
    ]
    ws.append(headers)
    
    # Обработка нейронов (сортировка по слою и номеру нейрона)
    for key in sorted(old_weights.keys(), key=lambda k: (k[0], k[1])):
        layer, neuron = key
        weights_old = old_weights.get(key, [])
        weights_new = new_weights.get(key, [])
        bias_old = old_biases.get(key, 1.0)
        bias_new = new_biases.get(key, 1.0)
        
        # Для каждого выхода (каждого веса)
        for i, (w_old, w_new) in enumerate(zip(weights_old, weights_new), start=1):
            # В первой строке для данного нейрона выводим также смещение,
            # а в остальных строках оставляем его пустым.
            row = [
                layer if layer != 2 else "Выход",  # для выходного слоя можно заменить номером или словом "Выход"
                neuron,
                i,
                round(w_old, 8),
                round(bias_old, 8) if i == 1 else "",
                round(w_new, 8),
                round(bias_new, 8) if i == 1 else ""
            ]
            ws.append(row)
    
    # Автоматическая подгонка ширины колонок
    for col in ws.columns:
        max_length = 0
        column = get_column_letter(col[0].column)
        for cell in col:
            if cell.value:
                max_length = max(max_length, len(str(cell.value)))
        ws.column_dimensions[column].width = max_length + 2
    
    wb.save(output_filename)

# Пример использования модуля:
if __name__ == "__main__":
    # Здесь должны быть подготовлены данные (словарь old_weights, old_biases, new_weights, new_biases)
    # Пример для демонстрации:
    old_weights = {
        (1, 1): [-0.464, 0.904, 0.906],
        (1, 2): [-0.068, 0.518, 0.744],
        (1, 3): [-0.318, 0.578, -0.404],
        (1, 4): [0.032, 0.372, -0.616],
        (1, 5): [-0.034, -0.572, -0.846],
        (1, 6): [-0.336, 0.254, 0.296],
        (1, 7): [0.078, -0.814, 0.118],
        (1, 8): [0.78, 0.964, 0.55],
        (1, 9): [-0.438, -0.722, -0.606],
        (1, 10): [-0.41, 0.586, 0.956],
        (2, 1): [0.318, -0.792, -0.546, 0.444, -0.358, -0.354, 0.136, -0.39, 0.782, 0.754]
    }
    old_biases = {
        (1, 1): 1,
        (1, 2): 1,
        (1, 3): 1,
        (1, 4): 1,
        (1, 5): 1,
        (1, 6): 1,
        (1, 7): 1,
        (1, 8): 1,
        (1, 9): 1,
        (1, 10): 1,
        (2, 1): 1
    }
    new_weights = {
        (1, 1): [-0.46400007, 0.90399993, 0.90599993],
        (1, 2): [-0.06799981, 0.51800019, 0.74400019],
        (1, 3): [-0.31799976, 0.57800024, -0.40399976],
        (1, 4): [0.0319998, 0.3719998, -0.6160002],
        (1, 5): [-0.03399978, -0.57199978, -0.84599978],
        (1, 6): [-0.33599986, 0.25400014, 0.29600014],
        (1, 7): [0.07799993, -0.81400007, 0.11799993],
        (1, 8): [0.78000005, 0.96400005, 0.55000005],
        (1, 9): [-0.43800052, -0.72200052, -0.60600052],
        (1, 10): [-0.41000019, 0.58599981, 0.95599981],
        (2, 1): [0.31799123, -0.79200985, -0.5460176, 0.44398179, -0.35802532,
                  -0.35401556, 0.1359786, -0.39000521, 0.7819734, 0.75399]
    }
    new_biases = {
        (1, 1): 0.99999974,
        (1, 2): 1.00000065,
        (1, 3): 1.00000045,
        (1, 4): 0.99999964,
        (1, 5): 1.00000029,
        (1, 6): 1.00000029,
        (1, 7): 0.99999989,
        (1, 8): 1.00000032,
        (1, 9): 0.99999937,
        (1, 10): 0.99999938,
        (2, 1): 0.9999673
    }
    create_excel_table(old_weights, old_biases, new_weights, new_biases, "table10.xlsx")
